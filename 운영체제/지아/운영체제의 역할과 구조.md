## 1. 운영 체제란 무엇인가?
### 운영 체제(OS, Operating System)
- 하드웨어를 관리하고, 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 응용 프로그램과 하드웨어 간의 인터페이스로써 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공함.
- 즉, 운영 체제는 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어라고 할 수 있다.
- 종류로는 **Windows, Linux, UNIX, MS-DOS** 등이 있으며, 시스템의 역할 구분에 따라 각각 용이점이 있다.
- 운영체제와 유사하지만, 소프트웨어를 추가로 설치할 수 없는 것을 **펌웨어** 라고 함.

### 운영체제의 역할
#### 1. 프로세스 관리
- **프로세스/ 스레드, 스케줄링동기화, IPC 통신**
- 운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.
- 프로세서(CPU) 관리하는 것이라고 볼 수도 있다. 
- 현재 CPU를 점유해야 할 **프로세스를 결정**하고, **실제로 CPU를 프로세스에 할당**하며, 이 **프로세스 간 공유 자원 접근과 통신**, 프로세스의 **생성과 삭제**, **자원 할당 및 반환** 등을 관리하게 된다.

#### 2. 저장장치 관리
- **메모리 관리, 가상 메모리, 파일 시스템**
- 1차 저장장치에 해당하는 **메인 메모리**와 2차 저장장치에 해당하는 **하드디스크, NAND 등**을 관리하는 기능이다.

##### 1차 저장장치(Main Memory)란?
- 프로세스에 할당하는 메모리 영역의 할당과 해제
- 각 메모리 영역 간의 침범 방지
- 메인 메모리의 효율적 활용을 위한 가상 메모리 기능

##### 2차 저장장치(HDD, NAND Flash Memory 등)란?
- 파일 형식의 데이터 저장
- 이런 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리
- FAT, NTFS, EXT2, JFS, XFS 등 많은 파일 시스템들이 개발되어 사용 중

#### 3. 네트워킹
- TCP/IP, 기타 프로토콜
- TCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 운영체제에서 네트워크 프로토콜을 지원해야 한다. 
- 현재 상용 OS들은 다양하고 많은 네트워크 프로토콜을 지원한다.

#### 4. 사용자 관리
- 계정 관리, 접근권한 관리
- 하나의 PC로도 여러 사람이 사용하는 경우가 많기 때문에, 운영체제는 한 컴퓨터를 여러 사람이 사용하는 환경도 지원해야 한다. 
- 따라서, 운영체제는 각 계정을 관리할 수 있는 기능이 필요하다. 사용자 별로 프라이버시와 보안을 위해 개인 파일에 대해선 다른 사용자가 접근할 수 없도록 해야 한다. 
- 이 밖에도 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원하는 것이 사용자 관리 기능이다.

#### 5. 디바이스 드라이버
- 순차접근 장치, 임의접근 장치, 네트워크 장치
- 운영체제는 시스템의 자원, 하드웨어를 관리한다. 시스템에는 여러 하드웨어가 붙어있는데, 이들을 운영체제에서 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 한다.
- 따라서, 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하다. 이 계층이 바로 디바이스 드라이버라고 불린다. 하드웨어의 종류가 많은 만큼, 운영체제 내부의 디바이스 드라이버도 많이 존재한다.
- 이러한 수많은 디바이스 드라이버들을 관리하는 기능 또한 운영체제가 맡고 있다.

![](https://velog.velcdn.com/images/cil05265/post/203a0418-39d0-44b3-90ee-e00032a851a2/image.png)

### 운영체제의 구조
-  유저 프로그램, **GUI, 시스템콜, 커널, 드라이버**, 하드웨어 순으로 구성이 되어있다.
- 이 중 **GUI, 시스템콜, 커널, 드라이버**가 운영체제를 지칭한다.

> GUI
사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태, 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 해준다.

>드라이버
하드웨어를 제어하기 위한 소프트웨어

>CUI
그래픽이 아닌 명령어로 처리하는 인터페이스

![](https://velog.velcdn.com/images/cil05265/post/e0c2dbc2-c554-4717-bb15-a1b39af849e5/image.png)
![](https://velog.velcdn.com/images/cil05265/post/159db161-baf2-4b52-8832-dbf2391d5e01/image.png)

### 시스템콜
- 시스템콜이란 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다.
- 유저 프로그램이 **I/O 요청으로 트랩을 발동**하면 올바른 I/O 요청인지 확인한 후, **유저 모드가 시스템콜을 통해 커널 모드로 변환**되어 실행된다.
- 이 과정을 통해 컴퓨터 자원에 대한 직접 접근을 차단할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있다.

>I/O 요청
입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일

>드라이버
하드웨어를 제어하기 위한 소프트웨어

#### 시스템콜의 예시
- **fork( ), exec( ), wait( )**와 같은 것들은 Process 생성과 제어를 위한 System call의 종류이다.
- fork, exec는 새로운 Process 생성과 관련이 되어 있다.
- wait는 Process (Parent)가 만든 다른 Process(child) 가 끝날 때까지 기다리는 명령어이다.

##### 1.Fork
새로운 Process를 생성할 때 사용한다.

```c++
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146

    int rc = fork();     // 주목
    
    if (rc < 0) {
        exit(1);
    }         // (1) fork 실패
    else if (rc == 0) {     // (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
    }
    else {        // (3) parent case
        printf("parent of %d (pid : %d)", rc, (int)getpid());
    }
}
```

- 출력 예시
> pid : 29146 //프로세스 식별자. UNIX 시스템에서는 PID는 프로세스에게 명령을 할 때 사용함.
parent of 29147 (pid : 29146)
child (pid : 29147)

- parent와 child의 순서는 확신할 수 없음. scheduler가 결정하는 일임.

- 출력에 대한 해석
> Fork()가 실행되는 순간. 프로세스가 하나 더 생기는데, 이 때 생긴 프로세스(Child)는 fork를 만든 프로세스(Parent)와 (almost) 동일한 복사본을 갖게 된다. 
이 때 OS는 위와 똑같은 2개의 프로그램이 동작한다고 생각하고, fork()가 return될 차례라고 생각한다. 
그 때문에 새로 생성된 Process (child)는 main에서 시작하지 않고, if 문부터 시작하게 된다.
그러나, child와 parent의 fork() 값이 다르다는 점이다. 따라서, 완전히 동일한 복사본이라 할 수 없다.
Parent의 fork()값 => child의 pid 값
Child의 fork()값 => 0
Parent와 child의 fork 값이 다르다는 점은 매우 유용한 방식이다.
그러나, Scheduler가 부모를 먼저 수행할지 아닐지 확신할 수 없다. 따라서 아래와 같이 출력될 수 있다.

- 또 다른 출력의 예시
> pid : 29146
child (pid : 29147)
parent of 29147 (pid : 29146)

##### 2. wait
- child 프로세스가 종료될 때까지 기다리는 작업
- 위의 예시에 int wc = wait(NULL)만 추가함.

```c++
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146

    int rc = fork();     // 주목
    
    if (rc < 0) {
        exit(1);
    }         // (1) fork 실패
    else if (rc == 0) {     // (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
    }
    else {        // (3) parent case
        int wc = wait(NULL)    // 추가된 부분
        printf("parent of %d (wc : %d / pid : %d)", wc, rc, (int)getpid());
    }
}
```
- 출력 예시
> pid : 29146
child (pid : 29147)
parent of 29147 (wc : 29147 / pid : 29146)

- wait를 통해서, child의 실행이 끝날 때까지 기다려준다.
- parent가 먼저 실행되더라도, **wait ()는 child가 끝나기 전에는 return하지 않으므로, 반드시 child가 먼저 실행됨.**

##### 3. exec
- 단순 fork는 동일한 프로세스의 내용을 여러 번 동작할 때 사용함.
- child에서는 parent와 다른 동작을 하고 싶을 때는 exec를 사용할 수 있음.

```c++
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146

    int rc = fork();     // 주목
    
    if (rc < 0) {
        exit(1);
    }         // (1) fork 실패
    else if (rc == 0) {     // (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");  // 내가 실행할 파일 이름
        myargs[1] = strdup("p3.c");  // 실행할 파일에 넘겨줄 argument
        myargs[2] = NULL;    // end of array
        execvp(myarges[0], myargs);  // wc 파일 실행.
        printf("this shouldn't print out") // 실행되지 않음.
    }
    else {        // (3) parent case
        int wc = wait(NULL)    // 추가된 부분
        printf("parent of %d (wc : %d / pid : %d)", wc, rc, (int)getpid());
    }
}
```
- exec가 실행되면, execvp( 실행 파일, 전달 인자 ) 함수는, code segment 영역에 실행 파일의 코드를 읽어와서 덮어 씌운다.
- 씌운 이후에는, heap, stack, 다른 메모리 영역이 초기화되고, OS는 그냥 실행한다. **즉, 새로운 Process를 생성하지 않고, 현재 프로그램에 wc라는 파일을 실행한다.** 그로인해서, execvp() 이후의 부분은 실행되지 않는다.

- 프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때, 시스템 콜이라는 인터페이스와 커널을 거쳐 운영체제에 전달된다.
- 시스템콜은 하나의 추상화 계층이기 때문에, 네트워크 통신이나 데이터베이스와 같은 낮은 단계의 영역 처리에 대한 부분을 많이 신경쓰지 않고 프로그램을 구현할 수 있는 장점이 있다.

### 프로세스 & 스레드
- 프로세스란 **프로그램을 메모리 상에서 실행중인 작업**을 말한다.
- 스레드란 **프로세스 안에서 실행되는 여러 흐름 단위**를 말한다.
- 기본적으로 프로세스마다 최소 1개의 스레드 소유한다. (메인 스레드 포함)

![](https://velog.velcdn.com/images/cil05265/post/2e51162c-51b8-4646-96d5-08a07d09f86d/image.png)

프로세스는 각각 별도의 주소공간 할당하며, 독립적이다.
- **Code**는 코드 자체를 구성하는 메모리 영역(프로그램 명령)이다.
- **Data**는 전역변수, 정적변수, 배열 등을 의미한다.
    - 초기화 된 데이터는 data 영역에 저장
    - 초기화 되지 않은 데이터는 bss 영역에 저장
- **Heap**는 동적 할당 시 사용 (new(), malloc() 등)한다.
- **Stack**은 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)이다.
- 스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유한다.
- 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성된다.
- 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재한다.

#### 멀티프로세스
- 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것을 의미한다.
- 장점으로는 안전성 (메모리 침범 문제를 OS 차원에서 해결)이 있다.
- 단점으로는 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하가 있다.

#### Context Switching
- 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정이다.
- 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말한다.
- 그러나, 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재한다.

#### 멀티 스레드
- 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것이다.
- 스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해준다.
- 장점으로는 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소 전역 변수와 정적 변수에 대한 자료 공유 가능한 것이 있다.
- 단점으로는 안전성 문제가 있다. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)가 된다.
    - 멀티스레드의 안전성에 대한 단점은 Critical Section 기법을 통해 대비함
        - 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정이다.
        - 상호 배제, 진행, 한정된 대기를 충족해야한다.

![](https://velog.velcdn.com/images/cil05265/post/8417047e-5b3d-4a6f-90f8-f7782c3a57fb/image.png)

#### Modebit
- 시스템콜이 작동될 때 modebit을 참고해서 유저 모드와 커널 모드를 구분한다. **modebit는 1, 0의 값을 가지는 플래그 변수**이다.
- **modebit의 0은 커널모드, 1은 유저모드**라고 설정되며, 유저 모드일 경우에는 시스템콜을 못하게 막아서 한정된 일만 가능하게 한다.

> 유저모드
유저가 접근할 수 있는 영역을 제한적으로 두며, 컴퓨터 자원에 함부로 침범하지 못하는 모드이다.

> 커널 모드
모든 컴퓨터 자원에 접근할 수 있는 모드이다.

> 커널
운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O요청 관리 등 운영체제의 중추적인 역할을 한다.
