# [CS 스터디] 동기&비동기, 블로킹&논블로킹

작성일: 2022년 12월 1일
태그: CS

# 동기와 비동기

[https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/](https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/)

[https://deveric.tistory.com/99](https://deveric.tistory.com/99)

[https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

# 처리해야 할 작업들이 여러개 있을때 이들을 바라보는 서로 다른 두가지 관점

## 작업의 실행 흐름처리가 어떤지에 따른 관점

<aside>
✔️ 한 작업이 다른 작업을 시작시킬 때, 다른 작업의 완료를 기다리거나, 기다리지 않더라도 다른 작업의 완료 여부를 지속적으로 확인하는지 여부가 관심사.
한 작업이 다른 작업을 시작하고나서 자신의 작업을 지속하여 수행하는지 여부는 관계없다.

</aside>

### 동기(****Synchronous)**

작업 A 가 작업 B를 호출 한 후 그 작업의 완료후 리턴을 기다리거나, 바로 리턴을 받더라도 B가 미완료 상태인 경우 B의 작업 완료 여부를 A가 스스로 계속 확인 하는 경우 A와 B 는 동기이다. = A와 B는 동기적으로 수행된다.

특징

1. 작업의 완료 순서가 항상 일정하다(멱등). = 작업이 일정한 순서를 가지고 진행된다.
2. 특정 시점에 동작중인 작업이 끝나는 동시에 다른 작업이 수행된다.

### 비동기(****Asynchronous)**

작업 A가 작업 B를 호출한 이후 작업 B의 완료 여부를 신경쓰지 않는다. 대신, 호출할 때 콜백함수(= 작업B가 끝난 후 실행되는 코드) 를 함께 전달하여 흐름을 제어한다.

특징

1. 작업의 완료 순서가 일정하지 않다(멱등X). = 작업이 일정한 순서를 가지고 실행되지 않는다.

## 특정 시점에 처리되는 작업이, 전체적인 작업을 막는지에 대한 관점

<aside>
✔️ 한 작업이 다른 작업을 호출했을 때, 다른 작업이 진행되는 동안 호출한 작업이 멈추는지 여부가 관심사.

</aside>

### 블로킹(Blocking)

작업 A 가 작업 B 를 호출했을 때 작업 B 가 수행되는 동안 작업 A 는 일시중지 되는 경우.

특징 

1. 일반적인 프로그래밍에서 함수 내에서 다른 함수를 호출할 경우 거의 대부분 블로킹으로 처리된다.

### 논블로킹(Non - Blocking)

작업 A 가 작업 B 를 호출했을 때 작업 B 가 수행되는 동안 작업 A 도 계속 실행 되는 경우.

# 두 관점으로 동시에 바라보기

## 동기 + 블로킹

<aside>
✔️ 작업 A 가 작업 B를 호출한 후 작업 B 가 완료되어 리턴하는 동안 작업 A는 아무것도 안하고 기다리는 경우

- 작업 A는 작업 B의 결과(리턴)을 필요로 한다. ⇒ 동기
- 작업 A는 작업 B가 실행되는 동안 일시중지한다. ⇒ 블로킹

</aside>

가장 일반적인 경우다. 대부분의 코드가 동기 + 블로킹으로 동작한다.

## 동기 + 논 블로킹

<aside>
✔️ 작업 A 가 작업 B를 호출한 후 작업 B는 즉시 리턴하지만, 아직 작업 B가 완료되지 않은 상태에서 작업 A가 자신의 작업을 진행하며 중간중간 작업 B의 완료 여부를 계속 확인하는 경우

- 작업 A는 작업 B의 결과를 필요로 한다(필요하니까 확인한다) ⇒ 동기
- 작업 B가 수행되는 동안 작업 A는 자신의 작업을 수행하면서 ~ ⇒ 논 블로킹

</aside>

웹페이지나, 게임에서 서버와의 통신작업이나, 보조저장장치로부터의 데이터 로드중 화면에 로딩율을 표시하는 경우가 대표적인 예시이다.

## 비동기 + 논 블로킹

<aside>
✔️ 작업 A 가 작업 B를 호출할 때, 작업 B의 완료후 실행할 코드(콜백 함수)를 같이 넘겨주고, 작업 A 는 자신의 작업을 계속 진행하며 작업 B의 결과를 신경쓰지않는 경우

- 작업 A가 작업 B의 결과를 신경쓰지 않는다 ⇒ 비동기
- 작업 A가 계속 자신의 작업을 수행한다 ⇒ 논 블로킹

</aside>

js 의 fetch API 를 사용한 코드가 예시이다.

## 비동기 + 블로킹

<aside>
✔️ 작업 A 가 작업 B를 호출할 때, 작업 B의 완료후 실행할 코드(콜백 함수)를 같이 넘겨주고, 작업 A는 일시정지 하는 경우

- 작업 A 가 작업 B에게 콜백 함수를 넘겨준다 ⇒ 비동기
- 작업 A가 일시정지한다 ⇒ 블로킹

</aside>

성능상의 이점이 없고, 코드 구조도 복잡한 두마리의 토끼를 모두 놓치는 경우이다.

보통 원해서 이런 상황이 생기지는 않고, 개발자의 실수나, 작업 A 의 내부에서 사용하는 외부 라이브러리가 블로킹으로 처리하는 경우에 발생한다.

후자의 경우 예를 들면, 각종 비동기적인 방식으로 DB 연결을 수행하는데 하필 DB가 MySql 이라 MySql 드라이버가 블로킹 방식으로 동작하는 경우를 들 수 있다.